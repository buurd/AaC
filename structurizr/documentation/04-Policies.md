# Architecture Validation Policies

This document describes the Open Policy Agent (OPA) policies used to validate the architecture, implementation, and security of the system. These policies are written in Rego and are executed by the `validate-architecture.sh` script.

## 1. Traceability Validation (`check_traceability.rego`)

**Purpose:**  
Ensures that every requirement (except top-level "context" requirements) traces back to a parent requirement. This enforces a hierarchical requirement structure, ensuring that low-level implementation details are justified by high-level architectural or business goals.

**How it works:**  
The policy iterates through all requirements defined in the YAML files. For each requirement where `c4_level` is not "context", it checks if the `tracesTo` field is present and non-empty. It also verifies that the ID referenced in `tracesTo` actually exists within the set of defined requirements. It supports `tracesTo` being either a single string or a list of strings.

## 2. Relation Validation (`check_relation.rego`)

**Purpose:**  
Validates that the relationships defined in the requirements (e.g., "Customer uses Webshop") are accurately reflected in the Structurizr architecture model. This ensures the architectural model stays in sync with the requirements.

**How it works:**  
The policy looks for requirements that have a `model_validation` block specifying a `source` and `destination`. It then searches the Structurizr model (exported to JSON) to find the corresponding elements (People, Software Systems, Containers, or Components). Finally, it verifies that a relationship exists between the source and destination elements in the model, and optionally checks if the relationship description matches the requirement.

## 3. Container Validation (`check_containers.rego`)

**Purpose:**  
Ensures that containers (e.g., Web Server, Database) required by the architecture are actually present in the Structurizr model. This validates the structural integrity of the system design.

**How it works:**  
The policy processes requirements with a `model_validation` block specifying a `parent` (Software System) and a `container`. It first checks if the parent system exists in the model. If found, it then checks if that system contains a container with the specified name.

## 4. Component Validation (`check_components.rego`)

**Purpose:**  
Verifies that specific components (e.g., Controllers, Repositories) required by the design are present within their respective containers in the Structurizr model. This enforces the internal structure of the application containers.

**How it works:**  
Similar to container validation, this policy iterates through requirements specifying a `container` and a `component`. It locates the container within the model and then checks its list of components to ensure the required component exists.

## 5. Implementation Validation (`check_implementation.rego`)

**Purpose:**  
Checks that the files required to implement a feature or component actually exist in the project's file system. This links the abstract architecture to the concrete codebase.

**How it works:**  
The policy reads requirements that have an `implementation_validation` block containing a `file_path`. It compares this path against a list of all files in the project (generated by the validation script). If the specified file is missing, a violation is reported.

## 6. Code Structure Validation (`check_class_structure.rego`)

**Purpose:**  
Validates the internal structure of Java classes, ensuring they contain specific fields or methods as required. This is used to enforce detailed design patterns or mandatory attributes in domain entities.

**How it works:**  
This policy uses requirements with a `code_validation` block. It reads the content of the specified Java file and uses regular expressions to check for the existence of specific fields (e.g., `private String name;`) or methods (e.g., `generateVariants`). It can also verify if the file itself exists.

## 7. Dependency Validation (`check_dependency.rego`)

**Purpose:**  
Enforces code-level dependencies, ensuring that classes interact with each other as intended (e.g., a Controller must depend on a Service or Repository). This validates the wiring of the application components.

**How it works:**  
The policy checks requirements with a `code_validation` block specifying a `dependency_class`. It scans the content of the source file for `import` statements, field declarations, or constructor arguments that reference the required dependency class using regex matching.

## 8. HTTPS Usage Validation (`check_https_usage.rego`)

**Purpose:**  
Scans the codebase (specifically test files) to ensure that no insecure HTTP URLs are used. This enforces the security requirement that all internal and external communication should be over HTTPS.

**How it works:**  
The policy iterates through the content of all JavaScript test files (e.g., Cypress tests). It searches for the string `http://` using a simple containment check. If found, it flags the file as containing an insecure URL violation.

## 9. Pact Verification Validation (`check_pact_verification.rego`)

**Purpose:**
Ensures that for every integration requirement specifying a consumer and provider, a corresponding Pact contract file exists. This enforces the "Contract Testing" policy (`REQ-059`).

**How it works:**
The policy checks requirements that have a `pact_validation` block containing `consumer` and `provider` fields. It constructs the expected Pact file path (e.g., `pacts/Consumer-Provider.json`) and verifies its existence in the project file list.

## 10. Kubernetes Deployment Validation (`check_k8s_deployment.rego`)

**Purpose:**
Ensures that the Kubernetes manifests in `infrastructure/k8s/` contain all the required Deployments and Services as defined in `REQ-078`. This provides a "double bookkeeping" check to keep the infrastructure-as-code synchronized with the architectural requirements.

**How it works:**
The policy reads the `k8s_validation` block from `REQ-078`. It then iterates through the list of `required_deployments` and `required_services`, checking if a corresponding resource with a matching `kind` and `metadata.name` exists in the set of parsed Kubernetes manifests.
